/**
 * ═══════════════════════════════════════════════════════════
 * QUOTATION HISTORY MODEL - Enterprise Audit Trail
 * ═══════════════════════════════════════════════════════════
 *
 * WHY DO WE NEED THIS?
 * In enterprise systems, you need to track WHO did WHAT and WHEN.
 * This is called an "audit trail" or "audit log".
 *
 * USE CASES:
 * - Track price changes (who changed the price and when)
 * - Track status changes (when was it quoted, approved, rejected)
 * - Compliance and legal requirements
 * - Dispute resolution
 * - Performance tracking (how long does admin take to respond)
 *
 * ENTERPRISE PATTERN: Event Sourcing
 * Instead of just storing the current state, we store every change.
 * This lets us:
 * - See the complete history
 * - Reconstruct past states
 * - Analyze trends
 * - Meet regulatory requirements (like GDPR, SOC2, ISO 27001)
 */

const mongoose = require('mongoose');

const quotationHistorySchema = new mongoose.Schema({
  /**
   * REFERENCE TO QUOTE REQUEST
   * Links this history entry to the original quote
   */
  quote: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'QuoteRequest',
    required: [true, 'Quote reference is required'],
    index: true // Index for faster queries
  },

  /**
   * WHO MADE THE CHANGE?
   * Track which admin user performed the action
   */
  changedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User reference is required']
  },

  /**
   * WHAT TYPE OF ACTION?
   * Different action types for different events
   */
  action: {
    type: String,
    enum: {
      values: [
        'created',         // Quote request created by customer
        'viewed',          // Admin viewed the quote
        'price_updated',   // Admin changed the price
        'status_changed',  // Status changed (pending -> quoted -> approved/rejected)
        'notes_added',     // Admin added notes
        'email_sent',      // Quotation email sent to customer
        'deleted'          // Quote was deleted
      ],
      message: 'Invalid action type'
    },
    required: [true, 'Action is required']
  },

  /**
   * PREVIOUS STATE
   * Store the old values before the change
   * This lets us see what changed
   */
  previousState: {
    status: String,
    estimatedPrice: Number,
    adminNotes: String
  },

  /**
   * NEW STATE
   * Store the new values after the change
   */
  newState: {
    status: String,
    estimatedPrice: Number,
    adminNotes: String
  },

  /**
   * ADDITIONAL METADATA
   * Extra information about the change
   */
  metadata: {
    // IP address of user who made the change (for security)
    ipAddress: String,

    // User agent (browser/device info)
    userAgent: String,

    // For email_sent action: was it successful?
    emailStatus: {
      type: String,
      enum: ['success', 'failed']
    },

    // For email_sent action: email message ID
    emailMessageId: String,

    // Any additional notes about this action
    comment: String
  },

  /**
   * TIMESTAMP
   * When did this happen? (auto-generated by Mongoose)
   */
}, {
  timestamps: true // Automatically adds createdAt and updatedAt
});

/**
 * INDEXES FOR PERFORMANCE
 *
 * Compound index: Optimize queries like "show me all history for this quote, sorted by time"
 * In enterprise systems, audit logs can grow very large, so indexes are critical
 */
quotationHistorySchema.index({ quote: 1, createdAt: -1 });
quotationHistorySchema.index({ changedBy: 1, createdAt: -1 });
quotationHistorySchema.index({ action: 1, createdAt: -1 });

/**
 * VIRTUAL: Get formatted timestamp
 *
 * Virtuals are fields that don't get saved to the database
 * but are computed on-the-fly when you access them
 */
quotationHistorySchema.virtual('formattedTimestamp').get(function() {
  return this.createdAt.toLocaleString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
});

/**
 * STATIC METHOD: Create History Entry
 *
 * Helper function to easily create history entries
 * This ensures consistency across the application
 *
 * USAGE:
 * await QuotationHistory.createEntry({
 *   quoteId: quote._id,
 *   userId: admin._id,
 *   action: 'price_updated',
 *   previousState: { estimatedPrice: 1000 },
 *   newState: { estimatedPrice: 1200 }
 * });
 */
quotationHistorySchema.statics.createEntry = async function(data) {
  const { quoteId, userId, action, previousState, newState, metadata } = data;

  const historyEntry = await this.create({
    quote: quoteId,
    changedBy: userId,
    action,
    previousState: previousState || {},
    newState: newState || {},
    metadata: metadata || {}
  });

  return historyEntry;
};

/**
 * STATIC METHOD: Get Quote History
 *
 * Retrieve all history for a specific quote, sorted by time
 *
 * USAGE:
 * const history = await QuotationHistory.getQuoteHistory(quoteId);
 */
quotationHistorySchema.statics.getQuoteHistory = async function(quoteId) {
  return this.find({ quote: quoteId })
    .populate('changedBy', 'firstName lastName email role')
    .sort({ createdAt: -1 }) // Newest first
    .lean(); // Convert to plain JavaScript objects (better performance)
};

/**
 * STATIC METHOD: Get Admin Activity
 *
 * Track what an admin has been doing (for performance reviews)
 *
 * USAGE:
 * const activity = await QuotationHistory.getAdminActivity(adminId, { limit: 50 });
 */
quotationHistorySchema.statics.getAdminActivity = async function(adminId, options = {}) {
  const { limit = 100, skip = 0 } = options;

  return this.find({ changedBy: adminId })
    .populate('quote')
    .sort({ createdAt: -1 })
    .limit(limit)
    .skip(skip)
    .lean();
};

/**
 * INSTANCE METHOD: Get Description
 *
 * Generate human-readable description of this history entry
 *
 * USAGE:
 * const description = historyEntry.getDescription();
 * // Returns: "Price updated from $1,000 to $1,200"
 */
quotationHistorySchema.methods.getDescription = function() {
  switch (this.action) {
    case 'created':
      return 'Quote request created';

    case 'viewed':
      return 'Quote viewed by admin';

    case 'price_updated':
      const oldPrice = this.previousState.estimatedPrice || 0;
      const newPrice = this.newState.estimatedPrice || 0;
      return `Price updated from $${oldPrice.toLocaleString()} to $${newPrice.toLocaleString()}`;

    case 'status_changed':
      return `Status changed from "${this.previousState.status}" to "${this.newState.status}"`;

    case 'notes_added':
      return 'Admin notes added or updated';

    case 'email_sent':
      const status = this.metadata?.emailStatus || 'unknown';
      return `Quotation email sent (${status})`;

    case 'deleted':
      return 'Quote request deleted';

    default:
      return 'Action performed';
  }
};

/**
 * PRE-SAVE HOOK
 *
 * This runs automatically before saving a history entry
 * Useful for validation or additional processing
 */
quotationHistorySchema.pre('save', function(next) {
  // Example: Ensure we don't save empty history entries
  if (!this.action) {
    return next(new Error('Action is required for history entry'));
  }

  next();
});

// Enable virtuals when converting to JSON
quotationHistorySchema.set('toJSON', { virtuals: true });
quotationHistorySchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('QuotationHistory', quotationHistorySchema);
